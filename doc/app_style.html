<HTML>
<CENTER><A HREF = "http://www.cs.sandia.gov/~sjplimp/spparks.html">SPPARKS WWW Site</A> - <A HREF = "Manual.html">SPPARKS Documentation</A> - <A HREF = "Section_commands.html#comm">SPPARKS Commands</A> 
</CENTER>






<HR>

<H3>app_style command 
</H3>
<P><B>Syntax:</B>
</P>
<PRE>app_style style args keyword values keyword values ... 
</PRE>
<UL><LI>style = <I>diffusion</I> or <I>ising</I> or <I>pore</I> or <I>potts</I> or <I>membrane</I> or <I>chemistry</I> or <I>test/group</I> 

<PRE>  (see application doc page for additional variants) 
</PRE>
<LI>args = arguments specific to an application 

<PRE>  (see application doc page for details) 
</PRE>
<LI>zero or more keyword/value pairs may be appended 

<LI>keyword = <I>lattice</I> or <I>site</I> or <I>input</I> 

<PRE>  <I>lattice</I> values = type params
    type = <I>sq/4n</I> or <I>sq/8n</I> or <I>tri</I> or <I>sc/6n</I> or <I>sc/26n</I> or <I>fcc</I> or <I>bcc</I> or <I>diamond</I> or <I>random/2d</I> or <I>random/3d</I> or <I>file</I>
      <I>sq/4n</I> params = a nx ny = 2d square lattice with 4 neighbors per site
      <I>sq/8n</I> params = a nx ny = 2d square lattice with 8 neighbors per site
      <I>tri</I> params = a nx ny = 2d triangular lattice with 6 neighborrs per site
        a = lattice constant
        nx,ny = number of unit cells in each dimension
      <I>sc/6n</I> params = a nx ny nz = 3d cubic lattice with 6 neighbors per site
      <I>sc/26n</I> params = a nx ny nz = 3d cubic lattice with 26 neighbors per site
      <I>fcc</I> params = a nx ny nz = 3d fcc lattice with 12 neighbors per site
      <I>bcc</I> params = a nx ny nz = 3d bcc lattice with 8 neighbors per site
      <I>diamond</I> params = a nx ny nz = 3d diamond lattice with 4 neighbors per site
        a = lattice constant
        nx,ny,nz = number of unit cells in each dimension
      <I>random/2d</I> param = N xbox ybox cutoff = lattice of random 2d points
        N = # of lattice points
	xbox,ybox = simulation extent in x,y
        cutoff = distance cutoff for neighbor connectivity between sites 
	seed = random number seed (positive integer)
      <I>random/3d</I> param = N xbox ybox zbox cutoff = lattice of random 3d points
        N = # of lattice points
	xbox,ybox,zbox = simulation extent in x,y,z
        cutoff = distance cutoff for neighbor connectivity between sites 
	seed = random number seed (positive integer)
      <I>file</I> param = filename = read lattice and connectivity from file
        filename = name of file (see file format below)
  <I>site</I> values = Nint Ndouble
    Nint = # of integer quantites to store per site
    Ndouble = # of double quantites to store per site
  <I>input</I> value = infile
    infile = filename for file containing initial state of all lattice sites 
</PRE>

</UL>
<P><B>Examples:</B>
</P>
<PRE>app_style diffusion ... lattice fcc 1.0 100 100 100 
</PRE>
<P>app_style ising ... lattice sq/4n 1.0 100 100
app_style ising ... lattice sq/4n 1.0 100 100 input restart.state
</P>
<PRE>app_style pore ... lattice fcc 1.0 100 100 100 
</PRE>
<P>app_style potts ... lattice file tmp.latttice
app_style potts/variable ... lattice random/2d 1000 10.0 10.0 3.0 49893
</P>
<P>app_style membrane ... lattice tri 1.0 100 50
</P>
<PRE>app_style chemistry ... 
</PRE>
<PRE>app_style test/group ... 
</PRE>
<P><B>Description:</B>
</P>
<P>This command defines what model or application SPPARKS will run.
There are 2 basic kinds of applications: on-lattice and off-lattice.
</P>
<P>Here is the list of on-lattice applications SPPARKS currently
includes.  See the doc page for each application for details:
</P>
<UL><LI><A HREF = "app_diffusion.html">diffusion</A> = vacancy exchange diffusion model
<LI><A HREF = "app_ising.html">ising</A> = Ising model
<LI><A HREF = "app_membrane.html">membrane</A> = membrane model of lipid,water,protein
<LI><A HREF = "app_ising.html">pore</A> = surface diffusion around thin-film pore
<LI><A HREF = "app_potts.html">potts</A> = multi-state Potts model for grain growth 
</UL>
<P>Here is the list of off-lattice applications SPPARKS currently
includes:
</P>
<UL><LI><A HREF = "app_chemistry.html">chemistry</A> = biochemical reaction networks
<LI><A HREF = "app_test_group.html">test/group</A> = artificial chemical networks that test <A HREF = "solve_style.html">solve_style</A> 
</UL>
<P>The off-lattice applications in SPPARKS can only be evolved via a
kinetic Monte Carlo (KMC) solver, specified by the
<A HREF = "solve_style.html">solve_style</A> command.  On-lattice applications can
be evolved by either a KMC solver or a rejection kinetic Monte Carlo
(rKMC) solver, specified by the <A HREF = "sweep_style.html">sweep_style</A>
command.  Not all on-lattice applications support both choices.
</P>
<P>The KMC algorithm is sometimes called rejection-free KMC or the N-fold
way or the Gillespie algorithm in the MC literature.  The application
defines a list of "events" and associated rates for each event.  The
solver chooses the next event, and the application updates the system
accordingly.  For off-lattice applications the definition of an
"event" is arbitrary.  For on-lattice application zero or more
possible events are typically defined for each lattice site.
</P>
<P>The rKMC algorithm picks successive lattice sites via some method (see
the <A HREF = "sweep_style.html">sweep_style</A> command), and an event on that site
which it accepts or rejects.  This is sometimes called null-event MC
in the literature.  The application again defines the "events" for
each site and associated rates which influence the acceptance or
rejection.
</P>
<P>Note that rKMC is different from Metropolis MC, which is sometimes
called thermodynamic equilibrium MC or barrier-free MC, in that rKMC
still uses rates to define events (often associated with the rate to
cross some energy barrier) and thus will track the dynamic evolution
of a system in a time-accurate manner as events are performed.
Metropolis MC is typically used to sample states from a system in
equilibrium or to drive a system to equilibrium (energy minimization).
via (possibly) non-physical events.  As such it has no requirement to
sample events with the correct relative probabilities or to limit
itself to physical events (e.g. it can change an atom to a new
species).  Because of this it also does not evolve the system in a
time-accurate manner; in general there is no "time" associated with
Metropolis MC events.
</P>
<P>However, to complicate matters, if an application defines rates for
its events based on energy differences between the initial and final
state of the event and a Metropolis-style accept/reject criterion
based on the Boltzmann factor, then it can be said to perform
Metropolis MC.  The KMC or rKMC options for an application in SPPARKS
can be written to define rates in this way, and thus the system will
evolve in a time-accurate manner, assuming the Metropolis rates are
correct in a relative sense.
</P>
<P>For both time evolution methods (KMC and rKMC) the rules for how
events are defined and are accepted or rejected are discussed in the
doc pages for the individual applications.
</P>
<HR>

<P>For on-lattice applications, there are several keyword/value 
pairs that may be used as part of the app_style command.
</P>
<P>The <I>lattice</I> keyword must be specified for on-lattice applications as
it determines the kind and size of lattice used.  For example,
</P>
<PRE>app_style ising 12345 lattice sq/4n 100 100 
</PRE>
<P>means use a 2d square lattice of size 100x100 with 4 neighbors per
lattice site.  A variety of lattice types and neighbor stencils can be
given as options with the <I>lattice</I> keyword as described above.
</P>
<P>The <I>sq</I> and <I>sc</I> lattice types are 2d square and 3d cubic lattices
The total number of lattice sites is one per unit cell, i.e. the
product of <I>nx</I>, <I>ny</I>, and <I>nz</I>.  The <I>fcc</I>, <I>bcc</I>, and <I>diamond</I>
lattice types are 3d and generate multiple lattice sites per unit
cell: 4 per fcc unit cell, 2 per bcc unit cell, and 8 per diamond unit
cell.
</P>
<P>The connectivity of these lattice types is as follows:
</P>
<UL><LI>sq/4n = 2d square lattice with 4 neighbors per site (nearest neighbors)
<LI>sq/8n = 2d square lattice with 4 neighbors per site (1st and 2nd nearest neighbors)
<LI>tri = 2d triangular lattice with 6 neighbors per site (nearest neighbors)
<LI>sc/6n = 3d cubic lattice with 6 neighbors per site (nearest neighbors)
<LI>sc/26n = 3d cubic lattice with 26 neighbors per site (1st,2nd,3rd nearest neighbors)
<LI>fcc = 3d fcc lattice with 12 neighbors per site (nearest neighbors)
<LI>bcc = 3d fcc lattice with 8 neighbors per site (nearest neighbors)
<LI>diamond = 3d fcc lattice with 4 neighbors per site (nearest neighbors) 
</UL>
<P>The <I>random/2d</I> and <I>random/3d</I> lattice options generate a lattice of
random points within a 2d or 3d box of specified size
(0-xbox,0-ybox,0-zbox), generated by a random number generator using
the specified <I>seed</I>.  The <I>cutoff</I> criterion is used to assign
lattice neighbors to each site.
</P>
<P>The <I>file</I> lattice option reads in a lattice and neighbor connectivity
from the specified <I>filename</I>.  The format of this file is as follows
where the comments (#) are not included in the file, and "vertex" is a
lattice site, and an "edge" is a neighbor connection from one site to
another.  Typically neighbors should be geometrically close, but that
is not required.  Note that a connection between two sites is listed
twice, once as edge IJ, and once as edge JI.
</P>
<PRE>comment              # 1st line is skipped
                     # skipped line
Ndim dimension       # Ndim = 2 or 3
N vertices           # N = number of vertices
M max connectivity   # M = maximum number of edges for any vertex
X1 X2 xlo xhi        # X1,X2 = x bounds of box that encloses lattice
Y1 Y2 xlo xhi        # y bounds
Z1 Z2 zlo zhi        # z bounds (only if Ndim = 3)
                     # skipped line
Vertices
                     # skipped line
1 x y z	             # ID, x, y, z for each vertex
2 x y z              # no z value if dim = 2
...
N x y z              # N lines in this section
                     # skipped line
Edges
                     # skipped line
1 n1 n2 n3 ...       # ID, list of IDs for neighbor connections
1 n1 n2 n3 ...       # can be different number of connections (up to M) for each vertex
...
N n1 n2 n3 ...       # N lines in this section 
</PRE>
<HR>

<P>For on-lattice applications, by default each lattice site stores a
single integer value.  By specifying <I>site</I>, multiple integer and or
double values can be stored on each site and accessed/updated by your
application.  For example, an integer flag could be stored for the
type of lattice site and one or more doubles could store the state of
the site.  If <I>site 0 0</I> is specified, then the default of a single
integer per site is used.
</P>
<HR>

<P>For on-lattice applications, you can initialize the values stored on
each lattice site explicitly by using the <I>input</I> keyword.  This can
be useful for restarting a simulation from the dump file generated by
a previous simulation.  See the "dump2input.py" script in the tools
directory for a way to convert a dump file to the input format
described below.
</P>
<P>Normally, if the <I>input</I> keyword is not used, the application will
initialize the lattice in some random manner.
</P>
<P>The file specified with the <I>input</I> keyword should have the following
format.  As before, the comments (#) need not be included in the file.
</P>
<PRE>comment              # 1st line is skipped
Nsite nvalue         # Nsite = total # of lattice sites, nvalue = values/site
                     # skipped line
1 value1 value2 ...
2 value1 value2 ...
...
Nsites value1 value2 ...   # Nsite lines 
</PRE>
<P>In the body of the file, there is one line per lattice site.  These
lines can be in any order.  The first field on the line is the ID of
the site, which should be an integer from 1 to Nsite.  There should be
"nvalue" remaining fields on each line.  These values are assigned to
that site.  How many values there should be (nvalue) depends on the
application.  For those with a single integer value (Nint = Ndouble =
0, nvalue = 1), just list that value.  If the <I>site</I> keyword is used
(Nint and/or Ndouble != 0, nvalue = Nint+Ndouble), then list the
integer value(s) first, followed by the double value(s).
</P>
<HR>

<P><B>Restrictions:</B> none
</P>
<P><B>Related commands:</B> none
</P>
<P><B>Default:</B>
</P>
<P>There is no default for the <I>lattice</I> keyword.  It must be specified
for on-lattice applications.  The default value for site is 0 0.
</P>
</HTML>
