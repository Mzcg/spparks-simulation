"SPPARKS WWW Site"_sws - "SPPARKS Documentation"_sd - "SPPARKS Commands"_sc :c

:link(sws,http://www.cs.sandia.gov/~sjplimp/spparks.html)
:link(sd,Manual.html)
:link(sc,Section_commands.html#comm)

:line

app_style command :h3

[Syntax:]

app_style style args keyword values keyword values ... :pre

style = {diffusion} or {ising} or {pore} or {potts} or {membrane} or {chemistry} or {test/group} :ulb,l
  (see application doc page for additional variants) :pre
args = arguments specific to an application :l
  (see application doc page for details) :pre
zero or more keyword/value pairs may be appended :l
keyword = {lattice} or {box} or {procs} or {site} or {input} :l
  {lattice} values = type params
    type = {line/2n} or {sq/4n} or {sq/8n} or {tri} or {sc/6n} or {sc/26n} or {fcc} or {bcc} or {diamond} or {random/1d} or {random/2d} or {random/3d} or {file}
      {line/2n} params = a nx = 1d regular lattice with 2 neighbors per site
      {sq/4n} params = a nx ny = 2d square lattice with 4 neighbors per site
      {sq/8n} params = a nx ny = 2d square lattice with 8 neighbors per site
      {tri} params = a nx ny = 2d triangular lattice with 6 neighborrs per site
        a = lattice constant
        nx,ny = number of unit cells in each dimension
      {sc/6n} params = a nx ny nz = 3d cubic lattice with 6 neighbors per site
      {sc/26n} params = a nx ny nz = 3d cubic lattice with 26 neighbors per site
      {fcc} params = a nx ny nz = 3d fcc lattice with 12 neighbors per site
      {bcc} params = a nx ny nz = 3d bcc lattice with 8 neighbors per site
      {diamond} params = a nx ny nz = 3d diamond lattice with 4 neighbors per site
        a = lattice constant
        nx,ny,nz = number of unit cells in each dimension
      {fcc/octa/tetra} params = a nx ny nz = 3d fcc/octa/tetra lattice
        a = lattice constant
        nx,ny,nz = number of unit cells in each dimension
      {random/1d} param = N xbox cutoff = lattice of random 1d points
        N = # of lattice points
	xbox = simulation extent in x
        cutoff = distance cutoff for neighbor connectivity between sites 
      {random/2d} param = N xbox ybox cutoff = lattice of random 2d points
        N = # of lattice points
	xbox,ybox = simulation extent in x,y
        cutoff = distance cutoff for neighbor connectivity between sites 
      {random/3d} param = N xbox ybox zbox cutoff = lattice of random 3d points
        N = # of lattice points
	xbox,ybox,zbox = simulation extent in x,y,z
        cutoff = distance cutoff for neighbor connectivity between sites 
      {file} param = filename = read lattice and connectivity from file
        filename = name of file (see file format below)
  {box} values = dim xlo xhi ylo yhi zlo zhi
    dim = dimension of system = 1,2,3
    xlo,xhi = lo/hi bounds of box in x dimension
    ylo,yhi = lo/hi bounds of box in y dimension (only listed for dim = 2,3)
    zlo,zhi = lo/hi bounds of box in z dimension (only listed for dim = 3)
  {procs} values = Px Py Pz
    Px,Py,Pz = # of processors assigned to each dimension of lattice
  {site} values = Nint Ndouble
    Nint = # of integer quantites to store per site
    Ndouble = # of double quantites to store per site
  {input} value = infile
    infile = filename for file containing initial state of all sites :pre
:ule

[Examples:]

app_style diffusion ... lattice fcc 1.0 100 100 100
app_style ising ... lattice sq/4n 1.0 100 100
app_style ising ... lattice sq/4n 1.0 100 100 input restart.state
app_style pore ... lattice fcc 1.0 100 100 100
app_style potts ... lattice file tmp.latttice
app_style potts/variable ... lattice random/2d 1000 10.0 10.0 3.0
app_style membrane ... lattice tri 1.0 100 50
app_style chemistry ...
app_style test/group ... :pre

[Description:]

This command defines what model or application SPPARKS will run.
There are 3 kinds of applications: general, on-lattice, and
off-lattice.

General applications typically involve no spatial information.  Here
is the list of general applications SPPARKS currently includes.  See
the doc page for each application for details:

"chemistry"_app_chemistry.html = biochemical reaction networks
"test/group"_app_test_group.html = artificial chemical networks that test "solve_style"_solve_style.html :ul

On-lattice applications define a lattice of points in space on which
events occur.  Here is the list of on-lattice applications SPPARKS
currently includes:

"diffusion"_app_diffusion.html = vacancy exchange diffusion model
"ising"_app_ising.html = Ising model
"membrane"_app_membrane.html = membrane model of lipid,water,protein
"pore"_app_pore.html = surface diffusion around thin-film pore
"potts"_app_potts.html = Potts model for grain growth
"potts/pin"_app_potts_pin.html = Potts model with pinning sites :ul

Off-lattice applications define points in space at which events occur,
but the points are not on a regular lattice.  Here is the list of
off-lattice applications SPPARKS currently includes.

"surf2d"_app_surf2d.html = 2d surface growth model :ul

The general and off-lattice applications in SPPARKS can only be
evolved via a kinetic Monte Carlo (KMC) solver, specified by the
"solve_style"_solve_style.html command.  On-lattice applications can
be evolved by either a KMC solver or a rejection kinetic Monte Carlo
(rKMC) solver, specified by the "sweep"_sweep.html command.  Not all
on-lattice applications support both choices.

The KMC algorithm is sometimes called rejection-free KMC or the N-fold
way or the Gillespie algorithm in the MC literature.  The application
defines a list of "events" and associated rates for each event.  The
solver chooses the next event, and the application updates the system
accordingly.  For general applications the definition of an "event" is
arbitrary.  For off-lattice applications, zero or more events are
typically defined for each site or particle.  For on-lattice
applications zero or more possible events are typically defined for
each lattice site.

The rKMC algorithm picks successive lattice sites via some method (see
the "sweep"_sweep.html command), and an event on that site which it
accepts or rejects.  This is sometimes called null-event MC in the
literature.  The application again defines the "events" for each site
and associated rates which influence the acceptance or rejection.

For both time evolution methods (KMC and rKMC) the rules for how
events are defined and are accepted or rejected are discussed in the
doc pages for the individual applications.

Here is a table of the different kinds of solvers and options that can
be used for on-lattice applications in SPPARKS.  Serial and parallel
refer to running on one or many processors.  Sector vs no-sector is
what is set by the "sector"_sector.html command.  The rKMC options
are set by the "sweep"_sweep.html command.

method,	serial/no-sectors, serial/sectors, parallel/no-sectors, parallel/sectors
exact KMC, yes, yes, no, yes
rKMC random, yes, yes, no, yes
rKMC raster, yes, yes, no, yes
rKMC color, yes, yes, yes, yes
rKMC color/strict, yes, no, yes, no :tb(ea=c)

Masking can also be turned on for rKMC algorithms via the
"sweep"_sweep.html command if the lo-level application supports it.

:line

For general applications, none of the keyword/value pairs can be used
as part of the app_style command.

For on-lattice applications, the {lattice} keyword must be specified.
The {procs}, {site}, and {input} keywords are optional.  The {box}
keyword cannot be specified.

For off-lattice applications, the {box} keyword must be specified.
The {procs}, {site}, and {input} keywords are optional, though the
{input} keyword is required if you wish to define any initial sites.
The {lattice} keyword cannot be specified.

:line

The {lattice} keyword must be specified for on-lattice applications as
it determines the kind and size of lattice used.  For example,

app_style ising 12345 lattice sq/4n 100 100 :pre

means use a 2d square lattice of size 100x100 with 4 neighbors per
lattice site.  A variety of lattice types and neighbor stencils can be
given as options with the {lattice} keyword as described above.

The {line} lattice type is a 1d regular lattice.  The {sq} and {sc}
lattice types are 2d square and 3d cubic lattices.  The total number
of lattice sites is one per unit cell, i.e. the product of {nx}, {ny},
and {nz}.  The {fcc}, {bcc}, and {diamond} lattice types are 3d and
generate multiple lattice sites per unit cell: 4 per fcc unit cell, 2
per bcc unit cell, and 8 per diamond unit cell.  The {fcc/octa/tetra}
lattice is more complex.  It is an fcc lattice with additional
interstitial sites at octahedral and tetrahedral locations, which can
be thought of as 3 inter-penetrating lattices.

The connectivity of these lattice types is as follows:

line/2d = 1d regular lattice with 2 neighbors per site (nearest neighbors)
sq/4n = 2d square lattice with 4 neighbors per site (nearest neighbors)
sq/8n = 2d square lattice with 4 neighbors per site (1st and 2nd nearest neighbors)
tri = 2d triangular lattice with 6 neighbors per site (nearest neighbors)
sc/6n = 3d cubic lattice with 6 neighbors per site (nearest neighbors)
sc/26n = 3d cubic lattice with 26 neighbors per site (1st,2nd,3rd nearest neighbors)
fcc = 3d fcc lattice with 12 neighbors per site (nearest neighbors)
bcc = 3d fcc lattice with 8 neighbors per site (nearest neighbors)
diamond = 3d fcc lattice with 4 neighbors per site (nearest neighbors)
fcc/octa/tetra = 3d lattice with up to 26 neighbors per site, depending on the site :ul

The {random} lattice options generate a lattice of random points
within a 1d, 2d, or 3d box of specified size (0-xbox,0-ybox,0-zbox).
The {cutoff} criterion is used to assign lattice neighbors to each
site.

The {file} lattice option reads in a lattice and neighbor connectivity
from the specified {filename}.  The format of this file is as follows
where the comments (#) are not included in the file, and "vertex" is a
lattice site, and an "edge" is a neighbor connection from one site to
another.  Typically neighbors should be geometrically close, but that
is not required.  Note that a connection between two sites is listed
twice, once as edge IJ, and once as edge JI.

comment              # 1st line is skipped
                     # skipped line
Ndim dimension       # Ndim = 1 or 2 or 3
N vertices           # N = number of vertices
M max connectivity   # M = maximum number of edges for any vertex
X1 X2 xlo xhi        # X1,X2 = x bounds of box that encloses lattice
Y1 Y2 xlo xhi        # y bounds (only if Ndim > 1)
Z1 Z2 zlo zhi        # z bounds (only if Ndim = 3)
                     # skipped line
Vertices
                     # skipped line
1 x y z	             # ID, x, y, z for each vertex
2 x y z              # no y value if dim = 1, no z value if dim = 2
...
N x y z              # N lines in this section
                     # skipped line
Edges
                     # skipped line
1 n1 n2 n3 ...       # ID, list of IDs for neighbor connections
1 n1 n2 n3 ...       # can be different number of connections (up to M) for each vertex
...
N n1 n2 n3 ...       # N lines in this section :pre

:line

The {box} keyword must be specified for off-lattice applications as it
determines the size and shape of the simulation domain.

The {dim} parameter is the dimensionality of the system.  The {lo/hi}
parameters are the extent of the simulation box.

:line

For on-lattice and off-lattice applications, SPPARKS will, by default,
decide how to partition the simulation domain across processors in
order to minimize communication of site information.  Typically this
will create a 2d grid of processors for 2d systems, and a 3d grid of
processors for 3d systems.

The {procs} keyword can be used to override the default and specify a
grid of Px by Py by Pz processors.  For 2d systems, Pz must be 1.  For
1d systems Py and Pz must be 1.  If {procs 0 0 0} is specified, then
SPPARKS will decide the partitioning.

:line

For on-lattice and off-lattice applications, each site, by default,
stores a single integer value.  By use of the {site} keyword, multiple
integer and or double values can be stored with each site and
accessed/updated by the application.  For example, an integer flag
could store for the type of lattice site and one or more doubles could
store the state of the site.  If {site 0 0} is specified, then the
default of a single integer per site is used.

:line

For on-lattice and off-lattice applications, the values stored for
each site can be initialized by using the {input} keyword.

The {input} keyword must be used for off-lattice applications,
assuming there are any sites to intially define, as it is the only way
to initialize them.  For on-lattice applications, the application
itself may initialize the value(s) stored on the lattice of sites in
some manner.  But the {input} keyword can be useful for restarting a
simulation from the dump file generated by a previous simulation.  See
the "dump2input.py" script in the tools directory for a way to convert
a dump file to the input format described below.

The file specified with the {input} keyword should have the following
format.  As before, the comments (#) need not be included in the file.

NOTE: as discussed below, the x,y,z fields are only included for
off-lattice applications.

comment              # 1st line is skipped
Nsite nvalue         # Nsite = total # of lattice sites, nvalue = values/site
                     # skipped line
1 x y z value1 value2 ...      # Nsite lines
2 x y z value1 value2 ...      # only include x,y,z for off-lattice applications
...
Nsites x y z value1 value2 ... :pre

In the body of the file, there is one line per site.  These
lines can be in any order.  The first field on the line is the ID of
the site, which should be an integer from 1 to Nsite.  The x,y,z
fields are only listed for off-lattice applications, since they define
the location of the site within the simulation box.  For on-lattice
applications, the site locations are defined by the {lattice} keyword
and are NOT listed on each site line.

There should be "nvalue" remaining fields on each line.  These values
are assigned to that site.  How many values there should be (nvalue)
depends on the application.  For those with a single integer value
(Nint = Ndouble = 0, nvalue = 1), just list that value.  If the {site}
keyword is used (Nint and/or Ndouble != 0, nvalue = Nint+Ndouble),
then list the integer value(s) first, followed by the double value(s).

:line

[Restrictions:] none

[Related commands:] none

[Default:]

There is no default for the {lattice} keyword; it must be specified
for on-lattice applications.  There is no default for the {box}
keyword; it must be specified for off-lattice applications.  The
default values for the {procs} keyword are 0 0 0.  The default values
for the {site} keyword are 0 0.
