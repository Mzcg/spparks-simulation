"SPPARKS WWW Site"_sws - "SPPARKS Documentation"_sd - "SPPARKS Commands"_sc :c

:link(sws,http://www.cs.sandia.gov/~sjplimp/spparks.html)
:link(sd,Manual.html)
:link(sc,Section_commands.html#comm)

:line

app_style command :h3

[Syntax:]

app_style style args keyword values keyword values ... :pre

style = {diffusion} or {ising} or {pore} or {potts} or {membrane} or {chemistry} or {test/group} :ulb,l
  (see application doc page for additional variants) :pre
args = arguments specific to an application :l
  (see application doc page for details) :pre
zero or more keyword/value pairs may be appended :l
keyword = {lattice} or {procs} or {site} or {input} :l
  {lattice} values = type params
    type = {line/2n} or {sq/4n} or {sq/8n} or {tri} or {sc/6n} or {sc/26n} or {fcc} or {bcc} or {diamond} or {random/1d} or {random/2d} or {random/3d} or {file}
      {line/2n} params = a nx = 1d regular lattice with 2 neighbors per site
      {sq/4n} params = a nx ny = 2d square lattice with 4 neighbors per site
      {sq/8n} params = a nx ny = 2d square lattice with 8 neighbors per site
      {tri} params = a nx ny = 2d triangular lattice with 6 neighborrs per site
        a = lattice constant
        nx,ny = number of unit cells in each dimension
      {sc/6n} params = a nx ny nz = 3d cubic lattice with 6 neighbors per site
      {sc/26n} params = a nx ny nz = 3d cubic lattice with 26 neighbors per site
      {fcc} params = a nx ny nz = 3d fcc lattice with 12 neighbors per site
      {bcc} params = a nx ny nz = 3d bcc lattice with 8 neighbors per site
      {diamond} params = a nx ny nz = 3d diamond lattice with 4 neighbors per site
        a = lattice constant
        nx,ny,nz = number of unit cells in each dimension
      {random/1d} param = N xbox cutoff = lattice of random 1d points
        N = # of lattice points
	xbox = simulation extent in x
        cutoff = distance cutoff for neighbor connectivity between sites 
      {random/2d} param = N xbox ybox cutoff = lattice of random 2d points
        N = # of lattice points
	xbox,ybox = simulation extent in x,y
        cutoff = distance cutoff for neighbor connectivity between sites 
      {random/3d} param = N xbox ybox zbox cutoff = lattice of random 3d points
        N = # of lattice points
	xbox,ybox,zbox = simulation extent in x,y,z
        cutoff = distance cutoff for neighbor connectivity between sites 
      {file} param = filename = read lattice and connectivity from file
        filename = name of file (see file format below)
  {procs} values = Px Py Pz
    Px,Py,Pz = # of processors assigned to each dimension of lattice
  {site} values = Nint Ndouble
    Nint = # of integer quantites to store per site
    Ndouble = # of double quantites to store per site
  {input} value = infile
    infile = filename for file containing initial state of all lattice sites :pre
:ule

[Examples:]

app_style diffusion ... lattice fcc 1.0 100 100 100
app_style ising ... lattice sq/4n 1.0 100 100
app_style ising ... lattice sq/4n 1.0 100 100 input restart.state
app_style pore ... lattice fcc 1.0 100 100 100
app_style potts ... lattice file tmp.latttice
app_style potts/variable ... lattice random/2d 1000 10.0 10.0 3.0
app_style membrane ... lattice tri 1.0 100 50
app_style chemistry ...
app_style test/group ... :pre

[Description:]

This command defines what model or application SPPARKS will run.
There are 2 basic kinds of applications: on-lattice and off-lattice.

Here is the list of on-lattice applications SPPARKS currently
includes.  See the doc page for each application for details:

"diffusion"_app_diffusion.html = vacancy exchange diffusion model
"ising"_app_ising.html = Ising model
"membrane"_app_membrane.html = membrane model of lipid,water,protein
"pore"_app_ising.html = surface diffusion around thin-film pore
"potts"_app_potts.html = Potts model for grain growth
"potts/pin"_app_potts_pin.html = Potts model with pinning sites :ul

Here is the list of off-lattice applications SPPARKS currently
includes:

"chemistry"_app_chemistry.html = biochemical reaction networks
"test/group"_app_test_group.html = artificial chemical networks that test "solve_style"_solve_style.html :ul

The off-lattice applications in SPPARKS can only be evolved via a
kinetic Monte Carlo (KMC) solver, specified by the
"solve_style"_solve_style.html command.  On-lattice applications can
be evolved by either a KMC solver or a rejection kinetic Monte Carlo
(rKMC) solver, specified by the "sweep"_sweep.html command.  Not all
on-lattice applications support both choices.

The KMC algorithm is sometimes called rejection-free KMC or the N-fold
way or the Gillespie algorithm in the MC literature.  The application
defines a list of "events" and associated rates for each event.  The
solver chooses the next event, and the application updates the system
accordingly.  For off-lattice applications the definition of an
"event" is arbitrary.  For on-lattice application zero or more
possible events are typically defined for each lattice site.

The rKMC algorithm picks successive lattice sites via some method (see
the "sweep"_sweep.html command), and an event on that site which it
accepts or rejects.  This is sometimes called null-event MC in the
literature.  The application again defines the "events" for each site
and associated rates which influence the acceptance or rejection.

For both time evolution methods (KMC and rKMC) the rules for how
events are defined and are accepted or rejected are discussed in the
doc pages for the individual applications.

Here is a table of the different kinds of solvers and options that can
be used for on-lattice applications in SPPARKS.  Serial and parallel
refer to running on one or many processors.  Sector vs no-sector is
what is set by the "sector"_sector.html command.  The rKMC options
are set by the "sweep"_sweep.html command.

method,	serial/no-sectors, serial/sectors, parallel/no-sectors, parallel/sectors
exact KMC, yes, yes, no, yes
rKMC random, yes, yes, no, yes
rKMC raster, yes, yes, no, yes
rKMC color, yes, no, yes, no :tb(ea=c)

Note that the choice of {color} can also be {color/strict} and that
masking can also be turned on for rKMC algorithms via the
"sweep"_sweep.html command if the lo-level application supports it.

:line

For on-lattice applications, there are several keyword/value 
pairs that may be used as part of the app_style command.

The {lattice} keyword must be specified for on-lattice applications as
it determines the kind and size of lattice used.  For example,

app_style ising 12345 lattice sq/4n 100 100 :pre

means use a 2d square lattice of size 100x100 with 4 neighbors per
lattice site.  A variety of lattice types and neighbor stencils can be
given as options with the {lattice} keyword as described above.

The {line} lattice type is a 1d regular lattice.  The {sq} and {sc}
lattice types are 2d square and 3d cubic lattices.  The total number
of lattice sites is one per unit cell, i.e. the product of {nx}, {ny},
and {nz}.  The {fcc}, {bcc}, and {diamond} lattice types are 3d and
generate multiple lattice sites per unit cell: 4 per fcc unit cell, 2
per bcc unit cell, and 8 per diamond unit cell.

The connectivity of these lattice types is as follows:

line/2d = 1d regular lattice with 2 neighbors per site (nearest neighbors)
sq/4n = 2d square lattice with 4 neighbors per site (nearest neighbors)
sq/8n = 2d square lattice with 4 neighbors per site (1st and 2nd nearest neighbors)
tri = 2d triangular lattice with 6 neighbors per site (nearest neighbors)
sc/6n = 3d cubic lattice with 6 neighbors per site (nearest neighbors)
sc/26n = 3d cubic lattice with 26 neighbors per site (1st,2nd,3rd nearest neighbors)
fcc = 3d fcc lattice with 12 neighbors per site (nearest neighbors)
bcc = 3d fcc lattice with 8 neighbors per site (nearest neighbors)
diamond = 3d fcc lattice with 4 neighbors per site (nearest neighbors) :ul

The {random} lattice options generate a lattice of random points
within a 1d, 2d, or 3d box of specified size (0-xbox,0-ybox,0-zbox).
The {cutoff} criterion is used to assign lattice neighbors to each
site.

The {file} lattice option reads in a lattice and neighbor connectivity
from the specified {filename}.  The format of this file is as follows
where the comments (#) are not included in the file, and "vertex" is a
lattice site, and an "edge" is a neighbor connection from one site to
another.  Typically neighbors should be geometrically close, but that
is not required.  Note that a connection between two sites is listed
twice, once as edge IJ, and once as edge JI.

comment              # 1st line is skipped
                     # skipped line
Ndim dimension       # Ndim = 1 or 2 or 3
N vertices           # N = number of vertices
M max connectivity   # M = maximum number of edges for any vertex
X1 X2 xlo xhi        # X1,X2 = x bounds of box that encloses lattice
Y1 Y2 xlo xhi        # y bounds (only if Ndim > 1)
Z1 Z2 zlo zhi        # z bounds (only if Ndim = 3)
                     # skipped line
Vertices
                     # skipped line
1 x y z	             # ID, x, y, z for each vertex
2 x y z              # no y value if dim = 1, no z value if dim = 2
...
N x y z              # N lines in this section
                     # skipped line
Edges
                     # skipped line
1 n1 n2 n3 ...       # ID, list of IDs for neighbor connections
1 n1 n2 n3 ...       # can be different number of connections (up to M) for each vertex
...
N n1 n2 n3 ...       # N lines in this section :pre

:line

For on-lattice applications, by default SPPARKS will decide how to
partition the simulation domain across processors in order to minimize
communication of lattice sites.  Typically this will create a 2d grid
of processors for 2d lattices, and a 3d grid of processors for 3d
lattices.  You can override the default and specify your own grid of
Px by Py by Pz processors.  For 2d lattices, Pz must be 1.  For 1d
lattices Py and Pz must be 1.  If {procs 0 0 0} is specified, then
SPPARKS will decide the partitioning.

:line

For on-lattice applications, by default each lattice site stores a
single integer value.  By specifying {site}, multiple integer and or
double values can be stored on each site and accessed/updated by your
application.  For example, an integer flag could be stored for the
type of lattice site and one or more doubles could store the state of
the site.  If {site 0 0} is specified, then the default of a single
integer per site is used.

:line

For on-lattice applications, you can initialize the values stored on
each lattice site explicitly by using the {input} keyword.  This can
be useful for restarting a simulation from the dump file generated by
a previous simulation.  See the "dump2input.py" script in the tools
directory for a way to convert a dump file to the input format
described below.

Normally, if the {input} keyword is not used, the application will
initialize the lattice in some random manner.

The file specified with the {input} keyword should have the following
format.  As before, the comments (#) need not be included in the file.

comment              # 1st line is skipped
Nsite nvalue         # Nsite = total # of lattice sites, nvalue = values/site
                     # skipped line
1 value1 value2 ...
2 value1 value2 ...
...
Nsites value1 value2 ...   # Nsite lines :pre

In the body of the file, there is one line per lattice site.  These
lines can be in any order.  The first field on the line is the ID of
the site, which should be an integer from 1 to Nsite.  There should be
"nvalue" remaining fields on each line.  These values are assigned to
that site.  How many values there should be (nvalue) depends on the
application.  For those with a single integer value (Nint = Ndouble =
0, nvalue = 1), just list that value.  If the {site} keyword is used
(Nint and/or Ndouble != 0, nvalue = Nint+Ndouble), then list the
integer value(s) first, followed by the double value(s).

:line

[Restrictions:] none

[Related commands:] none

[Default:]

There is no default for the {lattice} keyword.  It must be specified
for on-lattice applications.  The default value for the {procs}
keyword are 0 0 0.  The default values for the {site} keyword are 0 0.
