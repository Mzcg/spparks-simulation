"Previous Section"_Section_commands.html - "KMC WWW Site"_kws -
"KMC Documentation"_kd - "KMC Commands"_kc - "Next
Section"_Section_example.html :c

:link(lws,http://KMC.sandia.gov)
:link(ld,Manual.html)
:link(lc,Section_commands.html#comm)

:line 

4. How-to discussions :h3

The following sections describe what commands can be used to perform
certain kinds of KMC simulations.

4.1 "Coupling KMC to other codes"_#4_1 :all(b)

The example input scripts included in the KMC distribution and
highlighted in "this section"_Section_example.html also show how to
setup and run various kinds of problems.

:line

4.1 Coupling KMC to other codes :link(4_1),h4

KMC is designed to allow it to be coupled to other codes.  For
example, a quantum mechanics code might compute forces on a subset of
atoms and pass those forces to KMC.  Or a continuum finite element
(FE) simulation might use atom positions as boundary conditions on FE
nodal points, compute a FE solution, and return interpolated forces on
MD atoms.

KMC can be coupled to other codes in at least 3 ways.  Each has
advantages and disadvantages, which you'll have to think about in the
context of your application.

(1) Define a new "fix"_fix.html command that calls the other code.  In
this scenario, KMC is the driver code.  During its timestepping,
the fix is invoked, and can make library calls to the other code,
which has been linked to KMC as a library.  This is the way the
"POEMS"_poems package that performs constrained rigid-body motion on
groups of atoms is hooked to KMC.  See the
"fix_poems"_fix_poems.html command for more details.  See "this
section"_Section_modify.html of the documentation for info on how to add
a new fix to KMC.

:link(poems,http://www.rpi.edu/~anderk5/lab)

(2) Define a new KMC command that calls the other code.  This is
conceptually similar to method (1), but in this case KMC and the
other code are on a more equal footing.  Note that now the other
code is not called during the timesteps of a KMC run, but between
runs.  The KMC input script can be used to alternate KMC runs
with calls to the other code, invoked via the new command.  The
"run"_run.html command facilitates this with its {every} option, which
makes it easy to run a few steps, invoke the command, run a few steps,
invoke the command, etc.

In this scenario, the other code can be a library, called by the
command, or it could be a stand-alone code, invoked by a system() call
made by the command (assuming your parallel machine allows one or more
processors to start up another program).  In the latter case the
stand-alone code could communicate with KMC thru files that the
command writes and reads.

See "this section"_Section_modify.html of the documentation for how to
add a new command to KMC.

(3) Use KMC as a library called by another code.  In this case the
other code is the driver and calls KMC as needed.  Or a wrapper
code could link and call both KMC and another code as libraries.
Again, the "run"_run.html command has options that allow it to be
invoked with minimal overhead (no setup or clean-up) if you wish to do
multiple short runs, driven by another program.

"This section"_Section_start.html#2_2 of the documentation describes 
how to build KMC as a library.  Once this is done, you can interface
with KMC either via C++, C, or Fortran (or any other language that
supports a vanilla C-like interface, e.g. a scripting language).  For
example, from C++ you could create an "instance" of KMC, and
initialize it, pass it an input script to process, or execute
individual commands, all by invoking the correct class methods in
KMC.  From C or Fortran you would make function calls to do the
same things.  Library.cpp and library.h contain such a C interface
that illustrates this with the functions:

void KMC_open(int, char **, MPI_Comm);
void KMC_close();
void KMC_file(char *);
char *KMC_command(char *); :pre

The functions contain the C++ code you would need to put in a C++
application that was invoking KMC directly.

Two of the routines in library.cpp are of particular note.  The
KMC_open() function initiates KMC and takes an MPI communicator
as an argument.  KMC will run on the set of processors in the
communicator.  This means the calling code can run KMC on all or a
subset of processors.  For example, a wrapper script might decide to
alternate between KMC and another code, allowing them both to run
on all the processors.  Or it might allocate half the processors to
KMC and half to the other code and run both codes simultaneously
before syncing them up periodically.

Library.cpp also contains a KMC_command() function to which the
caller passes a single KMC command (a string).  Thus the calling
code can read or generate a series of KMC commands (e.g. an input
script) one line at a time and pass it thru the library interface to
setup a problem and then run it.

A few other sample routines are included in library.cpp, but the key
idea is that you can write any routines you wish to define an
interface for how your code talks to KMC and add them to
library.cpp and library.h.  The routines you add can access any KMC
data.  The umbrella.cpp code in examples/couple is a simple example of
how a stand-alone code can link KMC as a library, run KMC on a
subset of processors, grab data from KMC, change it, and put it
back into KMC.
