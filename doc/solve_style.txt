"KMC WWW Site"_kws - "KMC Documentation"_kd - "KMC Commands"_kc :c

:link(kws,http://KMC.sandia.gov)
:link(kd,Manual.html)
:link(kc,Section_commands.html#comm)

:line

solve_style command :h3

[Syntax:]

solve_style style args :pre

style = {next_event_linear_search} 
      or {next_event_alias_search} 
      or {next_event_tree_search}
      or {next_event_group_search} :ulb,l

  {next_evnt_linear_search} args = seed
	seed = random seed (int) 
  {next_evnt_alias_search} args = seed
	seed = random seed (int) 
  {next_evnt_tree_search} args = seed
	seed = random seed (int) 
  {next_evnt_group_search} args = lo hi seed
	lo = distribution lower bound (double) 
	hi = distribution upper bound (double) 
	seed = random seed :pre

:ule

[Examples:]

solve_style next_event_linear_search 12338
solve_style next_event_tree_search 123123
solve_style next_event_group_search 0.0 1.0 123123 :pre

[Description:]

Choose the style of next event generator used for kinetic Monte Carlo
simulations performed by SPPARKS. 

The KMC simulation requires generation of random variates drawn form a
non-uniform dynamic distribution.  The solver in KMC performs both
event generation function and subsequent propensity table
updates. Efficient event generation requires complex data structures,
which make the update process difficult and expensive. The solver
algorithms are therefore classified by the scaling of event generation
and the scaling of the event update with the size of the event table.

The {next_event_linear_search} style treats the event table as a
cumulative distribution function to use as an inverse look-up random
variate algorithm.  The generation requires partial sum accumulation,
making it scale linearly in generation and constant time in the table
update.  Choose for small problems, since setup is cheap.

The {next_event_tree_search} style treats the event table as a
cumulative distribution function to use as an inverse look-up random
variate algorithm.  This algorithm constructs a binary tree of partial
sums to assist in quick search.  The generation is therefore
logarithmic time and logarithmic time in the table update.  This is an
excellent method for problems of moderate and large size with a
dynamic event table.

The {next_event_alias_search} style treats the event table as a
uniform distribution with a rejection step to choose one of two events
at each of the uniform bins. This algorithm requires two random
numbers per random variate value and is very efficient in event
generation in constant time. This comes at the expense of an expensive
table construction algorithm (linear at bbest, here quadratic in event
number). Currently, full table construction is required for each
update. So this algorithm is the method of choice for a fixed event
table only.

The {next_event_groups_search} style partitions the event table for an
efficient rejection method random variate algorithm. This algorithm
constructs a binary tree of partial sums of groups to assist in quick
search.  The generation is therefore sub-logarithmic time and constant
time in the table update.  This is an excellent method for problems of
very large size with a dynamic event table and large number of
dependencies.

[Related commands:] none

[Default:] none


