"Previous Section"_Section_intro.html - "KMC WWW Site"_kws - "KMC
Documentation"_kd - "KMC Commands"_kc - "Next
Section"_Section_commands.html :c

:link(kws,http://KMC.sandia.gov)
:link(kd,Manual.html)
:link(kc,Section_commands.html#comm)

:line

2. Getting Started :h3

This section describes how to unpack, make, and run KMC, for both
new and experienced users.

2.1 "What's in the KMC distribution"_#2_1
2.2 "Making KMC"_#2_2
2.3 "Running KMC"_#2_3
2.4 "Command-line options"_#2_4
2.5 "Screen output"_#2_5

:line

2.1 What's in the KMC distribution :h4,link(2_1)

When you download KMC you will need to unzip and untar the
downloaded file with the following commands, after placing the file in
an appropriate directory.

gunzip KMC*.tar.gz 
tar xvf KMC*.tar :pre

This will create a KMC directory containing two files and several
sub-directories:
    
README: text file
LICENSE: the GNU General Public License (GPL)
bench: benchmark problems
doc: documentation
examples: simple test problems
potentials: embedded atom method (EAM) potential files
src: source files
tools: pre- and post-processing tools :tb(s=:)

:line

2.2 Making KMC :h4,link(2_2)

[{Read this first:}]

Building KMC can be non-trivial.  You will likely need to edit a
makefile, there are compiler options, additional libraries can be used
(MPI, FFT), etc.  Please read this section carefully.  If you are not
comfortable with makefiles, or building codes on a Unix platform, or
running an MPI job on your machine, please find a local expert to help
you.  Many of the emails we get about build and run problems are not
really about KMC - they are peculiar to the user's system,
compilers, libraries, etc.  Such questions are better answered by a
local expert.

If you have a build problem that you are convinced is a KMC issue
(e.g. the compiler complains about a line of KMC source code), then
please send an email to the
"developers"_http://KMC.sandia.gov/authors.html.  Note that doesn't
include linking problems - that's a question for a local expert!

Also, if you succeed in building KMC on a new kind of machine
(which there isn't a similar Makefile for in the distribution), send
it to the developers and we'll include it in future KMC releases.

[{Building a KMC executable:}]

The src directory contains the C++ source and header files for KMC.
It also contains a top-level Makefile and a MAKE directory with
low-level Makefile.* files for several machines.  From within the src
directory, type "make" or "gmake".  You should see a list of available
choices.  If one of those is the machine and options you want, you can
type a command like:

make linux
gmake mac :pre

If you get no errors and an executable like lmp_linux or lmp_mac is
produced, you're done; it's your lucky day.  The remainder of this
section addressed the following topics: errors that occur when making
KMC, editing a new low-level Makefile.foo, how to make KMC with
and without packages, and additional build tips.

[{Errors that occur when making KMC:}]

(1) If the make command breaks immediately with errors that indicate
it can't find files with a "*" in their names, this can be because
your machine's make doesn't support wildcard expansion in a makefile.
Try gmake instead of make.  If that doesn't work, try using a -f
switch with your make command to use Makefile.list which explicitly
lists all the needed files, e.g.

make makelist
make -f Makefile.list linux
gmake -f Makefile.list mac :pre

The first "make" command will create a current Makefile.list with all
the file names in your src dir.  The 2nd "make" command (make or
gmake) will use it to build KMC.

(2) Other errors typically occur because the low-level Makefile isn't
setup correctly for your machine.  If your platform is named "foo",
you need to create a Makefile.foo in the MAKE directory.  Use whatever
existing file is closest to your platform as a starting point.  See
the next section for more instructions.

[{Editing a new low-level Makefile.foo:}]

These are the issues you need to address when editing a low-level
Makefile for your machine.  With a couple exceptions, the only portion
of the file you should need to edit is the "System-specific Settings"
section.

(1) Change the first line of Makefile.foo to include the word "foo"
and whatever other options you set.  This is the line you will see if
you just type "make".

(2) Set the paths and flags for your C++ compiler, including
optimization flags.  You can use g++, the open-source GNU compiler,
which is available on all Unix systems.  Vendor compilers often
produce faster code.  On boxes with Intel CPUs, I use the free Intel
icc compiler, which you can download from "Intel's compiler
site"_intel.

:link(intel,http://www.intel.com/software/products/noncom)

(3) If you want KMC to run in parallel, you must have an MPI
library installed on your platform.  Makefile.foo needs to specify
where the mpi.h file (-I switch) and the libmpi.a library (-L switch)
is found.  On my Linux box, I use Argonne's MPICH 1.2 which can be
downloaded from the "Argonne MPI
site"_http://www-unix.mcs.anl.gov/mpi.  LAM MPI should also work.  If
you are running on a big parallel platform, your system people or the
vendor should have already installed a version of MPI, which will be
faster than MPICH or LAM, so find out how to link against it.  If you
use MPICH or LAM, you will have to configure and build it for your
platform.  The MPI configure script should have compiler options to
enable you to use the same compiler you are using for the KMC
build, which can avoid problems that may arise when linking KMC to
the MPI library.

(4) If you just want KMC to run on a single processor, you can use
the STUBS library in place of MPI, since you don't need an MPI library
installed on your system.  See the Makefile.serial file for how to
specify the -I and -L switches.  You will also need to build the STUBS
library for your platform before making KMC itself.  From the STUBS
dir, type "make" and it will hopefully create a libmpi.a suitable for
linking to KMC.  If the build fails, you will need to edit the
STUBS/Makefile for your platform.

The file STUBS/mpi.cpp has a CPU timer function MPI_Wtime() that calls
gettimeofday() .  If your system doesn't support gettimeofday() ,
you'll need to insert code to call another timer.  Note that the
ANSI-standard function clock() rolls over after an hour or so, and is
therefore insufficient for timing long KMC runs.

(5) There are a few other -D compiler switches you can set as part of
CCFLAGS.  The read_data and dump commands will read/write gzipped
files if you compile with -DGZIP.  It requires that your Unix support
the "popen" command.  Using one of the -DPACK_ARRAY, -DPACK_POINTER,
and -DPACK_MEMCPY options can make for faster parallel FFTs (in the
PPPM solver) on some platforms.  The -DPACK_ARRAY setting is the
default.

(6) The DEPFLAGS setting is how the C++ compiler creates a dependency
file for each source file.  This speeds re-compilation when source
(*.cpp) or header (*.h) files are edited.  Some compilers do not
support dependency file creation, or may use a different switch than
-D.  GNU g++ works with -D.  If your compiler can't create dependency
files (a long list of errors involving *.d files), then you'll need to
create a Makefile.foo patterned after Makefile.tflop, which uses
different rules that do not involve dependency files.

That's it.  Once you have a correct Makefile.foo and you have
pre-built the MPI and FFT libraries it will use, all you need to do
from the src directory is type one of these 2 commands:

make foo
gmake foo :pre

You should get the executable lmp_foo when the build is complete.

[{Building KMC as a library:}]

KMC can be built as a library, which can then be called from
another application or a scripting language.  See "this
section"_Section_howto.html#4_1 for more info on coupling KMC to
other codes.  Building KMC as a library is done by typing

make makelib
make -f Makefile.lib foo :pre

where foo is the machine name.  The first "make" command will create a
current Makefile.lib with all the file names in your src dir.  The 2nd
"make" command will use it to build KMC as a library.  This
requires that Makefile.foo have a library target (lib) and
system-specific settings for ARCHIVE and ARFLAGS.  See Makefile.linux
for an example.  The build will create the file liblmp_foo.a which
another application can link to.  The callable functions in the
library are listed in library.h, but you can add as many functions as
you wish to library.h and library.cpp, which can access KMC data
and return it to the caller or set KMC data values as specified by
the caller. These 3 functions are included in the library:

void KMC_open(int, char **, MPI_Comm);
void KMC_close();
int KMC_command(char *); :pre

The KMC_open() function is used to initialize KMC, passing in a
list of strings as if they were "command-line arguments"_#2_4 when
KMC is run from the command line and a MPI communicator for KMC
to run under.  The KMC_close() function is used to shut down KMC
and free all its memory.  The KMC_command() function is used to
pass a string to KMC as if it were an input command read from an
input script.  See the library.h file for more information about the
arguments and return values for these 3 functions.

[{Additional build tips:}]

(1) Building KMC for multiple platforms.

You can make KMC for multiple platforms from the same src
directory.  Each target creates its own object sub-dir called Obj_name
where it stores the system-specific *.o files.

(2) Cleaning up.

Typing "make clean" will delete all *.o object files created when
KMC is built.

(3) On some 64-bit machines, compiling with -O3 appears to break the
Coulombic tabling option used by the "pair_style"_pair_style.html
{lj/cut/coul/long} and {lj/charmm/coul/long} styles.  By default,
tabling is used by these styles since it can offer a 2x speed-up.  It
can be disabled via the "pair_modify"_pair_modify.html command.
Alternatively, the associated files (e.g. pair_lj_cut_coul_long.cpp)
can be compiled with -O2, or with the compiler flag
{-fno-strict-aliasing}.  Either of those build changes seems to fix
the problem.

(4) Building for a Macintosh.

OS X is BSD Unix, so it already works.  See the Makefile.mac file.

(5) Building for MicroSoft Windows.

I've never done this, but KMC is just standard C++ with MPI and FFT
calls.  You should be able to use cygwin to build KMC with a Unix
make.  Or you should be able to pull all the source files into Visual
C++ (ugh) or some similar development environment and build it.  In
the src/MAKE/Windows directory are some notes from users on how they
built KMC under Windows, so you can look at their instructions for
tips.  Good luck - I can't help you on this one.

:line

2.3 Running KMC :h4,link(2_3)

By default, KMC runs by reading commands from stdin; e.g. lmp_linux
< in.file.  This means you first create an input script (e.g. in.file)
containing the desired commands.  "This section"_Section_commands.html
describes how input scripts are structured and what commands they
contain.

You can test KMC on any of the sample inputs provided in the
examples directory.  Input scripts are named in.* and sample outputs
are named log.*.name.P where name is a machine and P is the number of
processors it was run on.

Here is how you might run one of the Lennard-Jones tests on a Linux
box, using mpirun to launch a parallel job:

cd src
make linux
cp lmp_linux ../examples/lj
cd ../examples/lj
mpirun -np 4 lmp_linux < in.lj.nve :pre

The screen output from KMC is described in the next section.  As it
runs, KMC also writes a log.KMC file with the same information.
Note that this sequence of commands copied the KMC executable
(lmp_linux) to the directory with the input files.  If you don't do
this, KMC may look for input files or create output files in the
directory where the executable is, rather than where you run it from.

If KMC encounters errors in the input script or while running a
simulation it will print an ERROR message and stop or a WARNING
message and continue.  See "this section"_Section_errors.html for a
discussion of the various kinds of errors KMC can or can't detect,
a list of all ERROR and WARNING messages, and what to do about them.

KMC can run a problem on any number of processors, including a
single processor.  In theory you should get identical answers on any
number of processors and on any machine.  In practice, numerical
round-off can cause slight differences and eventual divergence of
molecular dynamics phase space trajectories.

KMC can run as large a problem as will fit in the physical memory
of one or more processors.  If you run out of memory, you must run on
more processors or setup a smaller problem.

:line

2.4 Command-line options :h4,link(2_4)

At run time, KMC recognizes several optional command-line switches
which may be used in any order.  For example, lmp_ibm might be
launched as follows:

mpirun -np 16 lmp_ibm -var f tmp.out -log my.log -screen none < in.alloy :pre

These are the command-line options:

-echo style :pre

Set the style of command echoing.  The style can be {none} or {screen}
or {log} or {both}.  Depending on the style, each command read from
the input script will be echoed to the screen and/or logfile.  This
can be useful to figure out which line of your script is causing an
input error.  The default value is {log}.  The echo style can also be
set by using the "echo"_echo.html command in the input script itself.

-partition 8x2 4 5 ... :pre

Invoke KMC in multi-partition mode.  When KMC is run on P
processors and this switch is not used, KMC runs in one partition,
i.e. all P processors run a single simulation.  If this switch is
used, the P processors are split into separate partitions and each
partition runs its own simulation.  The arguments to the switch
specify the number of processors in each partition.  Arguments of the
form MxN mean M partitions, each with N processors.  Arguments of the
form N mean a single partition with N processors.  The sum of
processors in all partitions must equal P.  Thus the command
"-partition 8x2 4 5" has 10 partitions and runs on a total of 25
processors.

The input script specifies what simulation is run on which partition;
see the "variable"_variable.html and "next"_next.html commands.
Simulations running on different partitions can also communicate with
each other; see the "temper"_temper.html command.

-in file :pre

Specify a file to use as an input script.  This is an optional switch
when running KMC in one-partition mode.  If it is not specified,
KMC reads its input script from stdin - e.g. lmp_linux < in.run.
This is a required switch when running KMC in multi-partition mode,
since multiple processors cannot all read from stdin.

-log file :pre

Specify a log file for KMC to write status information to.  In
one-partition mode, if the switch is not used, KMC writes to the
file log.KMC.  If this switch is used, KMC writes to the
specified file.  In multi-partition mode, if the switch is not used, a
log.KMC file is created with hi-level status information.  Each
partition also writes to a log.KMC.N file where N is the partition
ID.  If the switch is specified in multi-partition mode, the hi-level
logfile is named "file" and each partition also logs information to a
file.N.  For both one-partition and multi-partition mode, if the
specified file is "none", then no log files are created.  Using a
"log"_log.html command in the input script will override this setting.

-screen file :pre

Specify a file for KMC to write its screen information to.  In
one-partition mode, if the switch is not used, KMC writes to the
screen.  If this switch is used, KMC writes to the specified file
instead and you will see no screen output.  In multi-partition mode,
if the switch is not used, hi-level status information is written to
the screen.  Each partition also writes to a screen.N file where N is
the partition ID.  If the switch is specified in multi-partition mode,
the hi-level screen dump is named "file" and each partition also
writes screen information to a file.N.  For both one-partition and
multi-partition mode, if the specified file is "none", then no screen
output is performed.

-var name value :pre

Specify a variable that will be defined for substitution purposes when
the input script is read.  "Name" is the variable name which can be a
single character (referenced as $x in the input script) or a full
string (referenced as $\{abc\}).  The value can be any string.  Using
this command-line option is equivalent to putting the line "variable
name index value" at the beginning of the input script.  See the
"variable"_variable.html command for more info on defining variables
and "this section"_Section_commands.html#3_2 for more info on using
variables in scripts.

:line

2.5 KMC screen output :h4,link(2_5)

As KMC reads an input script, it prints information to both the
screen and a log file about significant actions it takes to setup a
simulation.  When the simulation is ready to begin, KMC performs
various initializations and prints the amount of memory (in MBytes per
processor) that the simulation requires.  It also prints details of
the initial thermodynamic state of the system.  During the run itself,
thermodynamic information is printed periodically, every few
timesteps.  When the run concludes, KMC prints the final
thermodynamic state and a total run time for the simulation.  It then
appends statistics about the CPU time and storage requirements for the
simulation.  An example set of statistics is shown here:

Loop time of 49.002 on 2 procs for 2004 atoms :pre

Pair   time (%) = 35.0495 (71.5267)
Bond   time (%) = 0.092046 (0.187841)
Kspce  time (%) = 6.42073 (13.103)
Neigh  time (%) = 2.73485 (5.5811)
Comm   time (%) = 1.50291 (3.06703)
Outpt  time (%) = 0.013799 (0.0281601)
Other  time (%) = 2.13669 (4.36041) :pre

Nlocal:    1002 ave, 1015 max, 989 min
Histogram: 1 0 0 0 0 0 0 0 0 1 
Nghost:    8720 ave, 8724 max, 8716 min 
Histogram: 1 0 0 0 0 0 0 0 0 1
Neighs:    354141 ave, 361422 max, 346860 min 
Histogram: 1 0 0 0 0 0 0 0 0 1 :pre

Total # of neighbors = 708282
Ave neighs/atom = 353.434
Ave special neighs/atom = 2.34032
Number of reneighborings = 42
Dangerous reneighborings = 2 :pre

Describe output.
