"SPPARKS WWW Site"_sws - "SPPARKS Documentation"_sd - "SPPARKS Commands"_sc :c

:link(sws,http://www.cs.sandia.gov/~sjplimp/spparks.html)
:link(sd,Manual.html)
:link(sc,Section_commands.html#comm)

:line

sweep_style command :h3

[Syntax:]

sweep_style style seed keyword value keyword value ... :pre

style = {lattice} or {lattice2d} or {lattice3d}
seed = random number seed (positive integer)
zero or more keyword/value pairs may be appended
keyword = {mask} or {strict} or {kmc} or {delt} or {adapt}
  {mask} value = {yes} or {no}
    yes/no = mask out sites than cannot change
  {strict} value = {yes} or {no}
    yes/no = loop over sites in color sets to achieve answers independent of parallelism and masking
  {kmc} value = {yes} or {no}
    yes/no = perform approximate kinetic MC algorithm
  {adapt} value = {yes} or {no}
    yes/no = adapt dt as the simulation proceeds to preserve accuracy
  {delt} value = dt
    dt = time associated with one sweep (seconds)

[Examples:]

sweep_style lattice2d seed option arg option arg ...
sweep_style lattice3d seed option arg option arg ... :pre

[Description:]

Choose a sweeping algorithm to use in your "lattice-based
application"_app_lattice.html.  If no sweeper is used then a kinetic
Monte Carlo (KMC) "solver"_solve_style.html is required.  If a sweeper
with the KMC option is used, then a solver is also required.

A sweep style can only be set for applications that are lattice based.
As explained in the app_style command, there are 3 kinds of lattices:
general, 2d, and 3d.  You must use a sweep_style of lattice for
general, latice2d for application on 2d lattices, and lattice3d on 3d
lattices.

A sweeper operates by looping over the sites on a lattice and
performing events on each site.  Your application defines the lattice,
what the events are, and their probabilities and acceptance/rejection
criteria.

In parallel, the simulation domain is partitioned into sub-domains,
one per processor.  For 2d lattices, the processors are mapped to a 2d
grid of rectangular sub-domains.  For 3d lattices, the processors are
likewise mapped to a 3d grid of brick-shaped sub-domains.  To insure
events occurring on one processor do not conflict with events
performed by another processor, each sub-domain is partitioned into
sectors.  There are 4 sectors per sub-domain in 2d, 8 sectors in 3d.
Even when running on one processor, the entire domain is partioned
into sectors.

A sweep is performed in the following manner.  All processors sweep
over sites in the same sector (e.g. their lower left sector in 2d) at
the same time.  Then communication between processors is performed to
update sites on the boundary.  Then all proecessors move to the next
sector, etc.  Thus a single sweep over the entire lattice is perfored
in 4 (or 8) stages of sector sweeping followed by communication for 2d
lattices (or 3d).

There are two basic ways to perform a sweep: ordered and random.  The
former is done with the mask and strict settings.  The latter is done
with the {kmc} keyword.  KMC on or off is ordered vs random.  Mask and
strict affect how the ordering is done, only apply to ordered. Adapt
applies to KMC.  Delt applies to both ordered and KMC, as explained
below.

If {mask} and {strict} and {kmc} are {no}, then a sector sweep is
simply a loop over all sites in the sector.  For 2d and 3d lattices
the looping is done in a standard way (i,j,k).  For general lattices
the ordering of the sites may be less structured, particularly for
random lattices or lattices read from files.

If {mask} is {yes}, the sweep ordering is the same, but sites can be
masked if no event is possible.  For example, in a grain growth model,
sites in the interior may never flip.  It is up to the application to
provide criteria for when a mask for a lattice site is set or unset.

If {strict} is {yes}, then coloring is used.  Goal is to provide
same answer in serial or parallel and for mask yes or no.  This can
be useful in debugging.

If {kmc} is {yes}, then {mask} and {strict} must be no.  A KMC "sweep"
is different than an ordered.  It really means that the lattice sites
within one sector are treated as a set of event probabilities.  A KMC
algorithm is used to choose events randomly.  Must use a "solve_style"
wtih the {kmc} option.  Events are chosed with boundary values on
sector frozen.  So is really an approximate algorithm in the spirit of
"Amar"_#Amar.  Continue choosing events until {delt} has elapsed.  Then
communicate and move to next sector.  After all sectors are complete,
{delt} has elapsed for the entire lattice and the simulation.

{Delt} means time for one sweep whether ordered sweep or KMC.


Amar paper

perform a Metroplis or KMC update of sites owned by a processor
  by sweeping over lattice sites in a regular fashion
must use lattice2d or lattice3d that correspods to the app_style (2d or 3d)
  do we check for this ??
used when running a lattice-based app (ising, potts, membrane, migration)

if define just a sweep style:
  domain will be broken into 4 or 8 sectors for 2d or 3d
  each will be iterated on in turn
  communication of boundary info will be done between sectors
if define just a solve style:
  no sweeping is done
  entire domain is treated as one set of KMC propensities
if define both a sweep and solve style:
  same partitioning into 4 or 8 sectors is done
  each sector is treated as one set of KMC propensities
  KMC updates are done until delt is reached
  then boundary is updated via communication
  this is an approximate parallel KMC algorithm
if use sweep style when running on 1 proc, entire domain is partitioned
  into 4 or 8 sectors

what does each option mean ??
which options can be used in combination and what do they mean ??
if KMC option is used, options strict, picklocal, mask are ignored
for KMC option, it's important to choose delt correctly
  how to choose correctly ??
  what happens if too small
  what happens if too large

[Restrictions:] none

[Related commands:]

"app_style"_app_style.html, "solve_style"_solve_style.html

[Default:]

The option defaults are mask = no, strict = no, kmc = no, adapt = no,
delt = 1.0.

:line

Amar
