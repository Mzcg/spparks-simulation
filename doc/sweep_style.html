<HTML>
<CENTER><A HREF = "http://www.cs.sandia.gov/~sjplimp/spparks.html">SPPARKS WWW Site</A> - <A HREF = "Manual.html">SPPARKS Documentation</A> - <A HREF = "Section_commands.html#comm">SPPARKS Commands</A> 
</CENTER>






<HR>

<H3>sweep_style command 
</H3>
<P><B>Syntax:</B>
</P>
<PRE>sweep_style style seed keyword value keyword value ... 
</PRE>
<UL><LI>style = <I>lattice</I> or <I>lattice2d</I> or <I>lattice3d</I> 

<LI>seed = random number seed (positive integer) 

<LI>zero or more keyword/value pairs may be appended 

<PRE>keyword = <I>mask</I> or <I>strict</I> or <I>kmc</I> or <I>delt</I> or <I>adapt</I>
  <I>mask</I> value = <I>yes</I> or <I>no</I>
    yes/no = mask out sites than cannot change
  <I>strict</I> value = <I>yes</I> or <I>no</I>
    yes/no = loop over sites in color sets for answers independent of parallelism and masking
  <I>kmc</I> value = <I>yes</I> or <I>no</I>
    yes/no = perform approximate kinetic MC algorithm
  <I>adapt</I> value = <I>yes</I> or <I>no</I>
    yes/no = adapt timestep as the simulation proceeds to preserve accuracy
  <I>delt</I> value = dt
    dt = time associated with one sweep (seconds)
  <I>deln</I> value = factor
    factor = unitless scale factor for time of one sweep scaled by propensity 
</PRE>

</UL>
<P><B>Examples:</B>
</P>
<PRE>sweep_style lattice2d seed option arg option arg ...
sweep_style lattice3d seed option arg option arg ... 
</PRE>
<P><B>Description:</B>
</P>
<P>Choose a sweeping algorithm to use in an on-lattice Monte Carlo
<A HREF = "app_style.html">application</A>.  If no sweeper is used then a kinetic
Monte Carlo (KMC) <A HREF = "solve_style.html">solver</A> is required.  If a sweeper
with the KMC option is used, then a solver is also required.
</P>
<P>As explained in the <A HREF = "app_style.html">app_style</A> command, there are 3
kinds of lattices: general, 2d, and 3d.  You must use a sweep style
that matches the application.  Namely, style <I>lattice</I> for
applications which use general lattices, style <I>lattice2d</I> for
applications which use 2d lattices, and style <I>lattice3d</I> for
applications which use 3d lattices.
</P>
<P>A sweeping algorithm loops over the sites on a lattice and requests
that the application perform events.  The application defines the
geometry and connectivity of the lattice, what the possible events
are, and defines their probabilities and acceptance/rejection
criteria.
</P>
<P>When SPPARKS runs in parallel, the simulation domain is partitioned
into sub-domains, one per processor.  For 2d lattices, the processors
are mapped to a 2d grid of rectangular sub-domains.  For 3d lattices,
the processors are likewise mapped to a 3d grid of brick-shaped
sub-domains.  To insure events occurring on one processor do not
conflict with events performed by another processor, each sub-domain
is partitioned into sectors.  There are 4 sectors per sub-domain in
2d, 8 sectors in 3d.  Even when running on one processor, the entire
domain is partitioned into sectors.
</P>
<P>A sweep is performed in the following manner.  All processors sweep
over sites in the same sector (e.g. their lower left sector in 2d) at
the same time.  Communication between processors is then performed to
update sites on the sector boundary.  Then all proecessors move to the
next sector, and the process is repeated.  Thus a single sweep over
the entire lattice is performed in 4 (or 8) stages for 2d (or 3d)
lattices, as sectors are swept over one at a time, followed by the
appropriate communication.
</P>
<P>There are two basic ways to perform a sweep: ordered and random.
</P>
<P>If the <I>kmc</I> keyword is <I>no</I>, then ordered sweeps are performed.  A
sector sweep is simply a loop over all sites in the sector.  For 2d
and 3d lattices the looping is done in a standard way (i,j,k).  For
general lattices the ordering of the sites may be less structured,
particularly for random lattices or lattices read from files.  Each
time a site is visited, the application is asked to perform an
event for the site via the Metropolis Monte Carlo algorithm with
an acceptance and rejection criterion.
</P>
<P>For ordered sweeps the <I>mask</I> and <I>strict</I> keywords can also be used
separately or together.  The <I>delt</I> keyword specifies how much time
elapses in the simulation per sweep.
</P>
<P>if the <I>mask</I> keyword is <I>yes</I>, the sweep ordering is the same, but
sites can be masked if no event is possible to save computational
time.  For example, in a grain growth model, sites in the interior of
a grain may never change.  It is up to the application to provide
criteria for when a lattice site mask is set or unset.  Masking can
not be invoked when the <A HREF = "temperature.html">temperature</A> is non-zero.
</P>
<P>For ordered sweeps, if the <I>strict</I> keyword is <I>yes</I>, then the lattice
sites are partitioned into "colors" such that lattice sites of the
same color do not interact with each other in an energetic sense.
Extra looping is done over colors and sectors to sweep through all the
sites.  The purpose of the <I>strict</I> option is to produce the same
answer independent of the number of processors being used and whether
masking is on or off.  This can be useful in debugging an application.
</P>
<P>If the <I>kmc</I> keyword is <I>yes</I>, then random sweeps are performed.  The
<I>mask</I> and <I>strict</I> keywords cannot be used.  In a random "sweep" the
sites within one sector are assigned event probabilities by the
application.  A kinetic Monte Carlo (KMC) algorithm is used to
randomly choose which site invokes the next event.  Thus a solver
style must be specified using the <A HREF = "solve_style">solve_style</A> command.
The KMC algorithm also computes a time associated with the selected
event and the time for that sector is incremented.  Event selection
continues until <I>delt</I> time has elapsed.  Then communication is
performed and the next sector executes a series of events.  Thus after
sweeping within all sectors is completed, <I>delt</I> has elapsed for the
entire system.
</P>
<P>Note that this is really an approximate KMC algorithm, in the spirit
of <A HREF = "#Amar">Amar</A>.  This is because events are occuring within a sector
while the state of the system on the boundary of the sector is held
frozen.  If <I>delt</I> is too large, this will induce incorrect dynamics
at the sector boundaries.  Conversely, if <I>delt</I> is too small, the
simulation will perform few events per sector and spend too much time
communicating.
</P>
<P>If the <I>adapt</I> keyword is <I>yes</I>, then <I>delt</I> is adjusted as
the simulation proceeds. This is done by holding deln fixed, 
where deln is defined by the equation:
</P>
<PRE>deln = delt*pmax 
</PRE>
<P>and pmax is the maximum propensity per site for one sector.  In
calculating pmax, we compare all sectors on all processor subdomains,
and sites with zero propensity are excluded.  The value of deln can be
calculated from <I>delt</I>, or it can be specified directly using the
<I>deln</I> keyword.  If <I>deln</I> is specified as 0 (the default), then deln
is computed from the initial state of the system.  As with delt,
larger values of deln may result in errors at sector boundaries, but
small values require more communication.  For high accuracy, deln ~ 1
should be adequate.
</P>
<P><B>Restrictions:</B> none
</P>
<P><B>Related commands:</B>
</P>
<P><A HREF = "app_style.html">app_style</A>, <A HREF = "solve_style.html">solve_style</A>
</P>
<P><B>Default:</B>
</P>
<P>The option defaults are mask = no, strict = no, kmc = no, adapt = no,
delt = 1.0, and deln = 0.0.
</P>
<HR>

<A NAME = "Amar"></A>

<P><B>(Amar)</B> Slepoy, Thompson, Plimpton, J Chem Phys, 128, 205101 (2008).
</P>
</HTML>
