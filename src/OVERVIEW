SPPARKS commands

This text file provides a quick, simple description of SPPARKS input
script commands, listed in alphabetic order.  Eventually it will be
turned into HTML documentation.

SPPARKS users can read this file to get a concise description of the
syntax and usage of each command.

Developers should use this file to keep track of the various features
added to the code.

When a command refers to an HTML doc page, it means the full
documentation for the command already exists as an HTML page in the
kmc/doc dir, e.g. doc/variable.html.

Commands not listed here directly (e.g. run, stats) are supported by
individual apps.  See the app documentation for a list of the commands
specific to the app.

-----------------------------------------------------------------------
* app_style

app_style style args ... options args

define an application for SPPARKS to run
see commands for individual styles

styles derived from AppLattice2d and AppLattice3d allow for
  the following options:
 
options = (random) or (read <filename>)

styles derived from the generic AppLattice allow for the 
  the following options:

options = lattice or site
  lattice style args ...
    2d styles = sq/4n or sq/8n or tri
      lattice sq/4n a nx ny
      lattice sq/8n a nx ny
      lattice tri a nx ny
        a = lattice constant
	nx,ny = number of square or rectangular unit cells
    3d styles = sc/6n or sc/26n or fcc or bcc or diamond
      lattice sc/6n a nx ny nz
      lattice sc/26n a nx ny nz
      lattice fcc a nx ny nz
      lattice bcc a nx ny nz
      lattice diamond a nx ny nz
        a = lattice constant
	nx,ny,nz = number of square or rectangular unit cells
    random styles = random/2d or random/3d
      lattice random/2d N xbox ybox cutoff
      lattice random/3d N xbox ybox zbox cutoff
        N = # of lattice points
	xbox,ybox,zbox = extent of simulation domain
	cutoff = distance cutoff for connectivity between sites
    file style = file
      lattice file filename
        filename = file that contains lattice points and connectivity
	see format below
  site N M
    N = # of int quantites to store on each site
    M = # of double quantites to store on each site
    if both are 0, then a single int is stored in the variable "lattice"
    otherwise multiple arrays of ints and doubles are stored

file format for the lattice file style:
  comment              # 1st line is skipped
	               # skipped line
  Ndim dimenion        # Ndim = 2 or 3
  N vertices           # N = global vertices
  M max connectivity   # M = maximum # of connections for any vertex
  X1 X2 xlo xhi        # x bounds
  Y1 Y2 xlo xhi        # y bounds
  Z1 Z2 zlo zhi        # z bounds (only if dim = 3)
                       # skipped line
  Vertices
                       # skipped line
  1 x y z	       # ID, x, y, z for each vertex
  2 x y z              # no z value if dim = 2
  ...
  N x y z
                       # skipped line
  Edges
                       # skipped line
  1 n1 n2 n3 ...       # ID, list of connection IDs for neighbors
  1 n1 n2 n3 ...       # can be different numbers of connections for each ID
  ...
  N n1 n2 n3 ...

option defaults: lattice = none, site 0 0

-----------------------------------------------------------------------
* app_style chemistry

app_style chemistry

evolve a set of coupled chemical reactions stochastically
produces a time trace of species concentrations
a Gillespie simulation like ChemCell performs
also need to define a "solve" style

Extra commands supported by this app:

add_species a b c3 mine ...
  add 1 or more chemical species
  must be done before using them in a reaction
add_reaction a b 3.0
add_reaction 1.0 d
add_reaction b2 1.0e-10 c3 d4 e3
  0,1,2 reactants produce 0 or more products at a rate
  units of rate depend on # of reactants
    0-reactants = rate is molarity/sec
    1-reactants = rate is 1/sec
    2-reactants = rate is 1/molarity-sec
count a2 10000
  set initial molecule count of species a2
  default = 0 for each species
volume value
  value = volume of system (liters)
  must be set

run 0.5
  run for time (seconds)


-----------------------------------------------------------------------
* app_style gppt

app_style gppt seed

seed = RN seed

run an app to do what ??
also need to define a "solve" style ??

Extra commands supported by this app: (doc these)

tree_type
population
tempering
fitness

run 0.5
  run for time (seconds)
dump lattice/coord 0.25
  dump snapshot every this often
  either in lattice format or LAMMPS atom format (coord)

-----------------------------------------------------------------------
* app_style ising

app_style ising seed options ...
app_style ising/2d/4n nx ny seed
app_style ising/2d/8n nx ny seed
app_style ising/3d/6n nx ny nz seed
app_style ising/3d/26n nx ny nz seed

nx,ny,nz = lattice size
seed = RN seed
options = options listed with the app_style command (e.g. lattice, site)

run an Ising model with different #'s of neighbors in stencil
style ising is a generic AppLattice that can be used with various lattices
style ising/... is a specific app for a particular lattice style
also need to define a "sweep" and/or "solve" style

Model:

site = spin 0 or 1
event = spin flip between 0 <-> 1

Hamiltonian:

- Sum_i Sum_j delta_ij

where Sum_i is over all sites
      Sum_j is over neighbors of site i
      delta_ij = 1 if spin_i = spin_j, else 0

Extra commands supported by these apps:

run 0.5
  run for time (seconds)
temperature 2.0
  set temperature for Boltzmann factor (energy units of Hamiltonian)
dump lattice/coord 0.25
  dump snapshot every this often
  either in lattice format or LAMMPS atom format (coord)
  app_style ising only allows for coord format

-----------------------------------------------------------------------
* app_style membrane

app_style membrane w01 w11 mu seed options ...
app_style membrane/2d nx ny w01 w11 mu seed

w01 = sovent-protein interaction energy (typically 1.25)
w11 = sovent-solvent interaction energy (typically 1.0)
mu = chemical potential to insert a solvent (typically -2.0)

nx,ny = lattice size
seed = RN seed
options = options listed with the app_style command (e.g. lattice, site)

run a 3-state membrane model
also need to define a "sweep" and/or "solve" style

Model:

site = one of 3 states (protein, lipid, solvent)
event = protein never changes, but other sites flip between lipid <-> solvent

Hamiltonian:

- mu Sum_i x_i - Sum_i Sum_j (w11 a_ij + w01 b_ij)

where Sum_i is over all sites
      Sum_j is over neighbors of site i
      mu,w11,w01 = user inputs
      x_i = 1 if site is solvent, else 0
      a_ij = 1 if both i,j sites are solvent, else 0
      b_ij = 1 if one of i,j is solvent and other is protein, else 0

This is a lattice gas GCMC model, isomorphic to a Ising model.  Basically
the mu term is a penalty for inserting solvent, to prevent the system
from going to all solvent (which the 2nd term would prefer).

Extra commands supported by this app:

inclusion xc yc r
  create a permanent circular protein inclusion at loc (xc,yc)
    of radius r

run 0.5
  run for time (seconds)
temperature 2.0
  set temperature for Boltzmann factor (energy units of Hamiltonian)
dump lattice/coord 0.25
  dump snapshot every this often
  app_style membrane only allows for coord format

-----------------------------------------------------------------------
* app_style migration

app_style migration latstyle material a nx ny nz seed

latstyle = fcc_12nn_100_011, fcc_12nn_111, hcp_12nn_0001,
	   fcc_12nn_100_010, fcc_12nn_110
material = Al
a = lattice constant (Angstroms)
nx,ny,nz = lattice size
seed = RN seed

run an electromigration model of vacancy diffusion in a wire
Hamiltonian = 
also need to define a "sweep" and/or "solve" style

Extra commands supported by this app:

boundaries xlo xhi ylo yhi zlo zhi
  each value is "fixed" or "free" or "periodic" for each of 6 sides of 3d wire
vacancies bulk surf nx1 nx2 ny1 ny2 nz1 nz2
  not sure what these mean
bias value
  value = electric field bias to apply along x-length of wire (units?)

run 0.5
  run for time (seconds)
temperature 2.0
  set temperature for Boltzmann factor (energy units of Hamiltonian)
dump lattice/coord 0.25
  dump snapshot every this often
  either in lattice format or LAMMPS atom format (coord)

-----------------------------------------------------------------------
* app_style potts

app_style potts seed nspins options ...
app_style potts/variable seed nspins options ...

app_style potts/2d/4n nx ny nspins seed
app_style potts/2d/8n nx ny nspins seed
app_style potts/2d/24n nx ny nspins seed

app_style potts/3d/6n nx ny nz nspins seed
app_style potts/3d/26n nx ny nz nspins seed
app_style potts/3d/12n nx ny nz nspins seed

nx,ny,nz = lattice size
nspins = # of possible spins
seed = RN seed
options = options listed with the app_style command (e.g. lattice, site)

run a Potts model with different #'s of neighbors in stencil
style potts is a generic AppLattice that can be used with various lattices
style potts/variable is a generic AppLattice
  that can be used with various lattices and also defines one int spin per site
style potts/... is a specific app for a particular lattice style
  24n and 12n define special 2-hop stencils
also need to define a "sweep" and/or "solve" style

Model:

site = integer spin from 1 to Q
event = flip a spin to a neighboring site value

Hamiltonian:

- Sum_i Sum_j delta_ij

where Sum_i is over all sites
      Sum_j is over neighbors of site i
      delta_ij = 1 if spin_i = spin_j, else 0

Rate: Min[1,exp(-E/kT)], where E is the energy change due to the spin flip.

More general Potts model:

The energy is a function of the site spin, neighbor spins, and one or
more field values (spin, etc).

The neighborhood for exchanges may not be the same as
the neighborhood used to compute site energies.

A mobility prefactor M(t) may be put in front of the rate factor.

Extra commands supported by these apps:

run 0.5
  run for time (seconds)
temperature 2.0
  set temperature for Boltzmann factor (energy units of Hamiltonian)
dump lattice/coord 0.25
  dump snapshot every this often
  either in lattice format or LAMMPS atom format (coord)

-----------------------------------------------------------------------
* app_style surf

app_style surf nlattice strain seed

nlattice = lateral extent of simulation box
strain = fractional strain in substrate (1.0 = no strain, 1.1 = 10%)
seed = RN seed

perform a 1+1d off-lattice surface growth simulation
1+1d means a 2d simulation where a 1d surface grows vertically
an initial substrate of immobile atoms is put down
subsequent events are depositions and lateral diffusive hops by ad-atoms
deposition event: atom is brought down from infinity at random position
  allowed to relax on surface via CG
diffusion event: ad-atom can hop left or write over barrier
  barrier heights determine propensity for 2 events
  after hop, atom is relaxed via CG
currently only the event atom is relaxed
  eventually the atom's neighborhood or entire lattice will be relaxed
also need to define a "solve" style
currently runs only in serial

Extra commands supported by this app:

potential 3.0
  set cutoff for interatomic potential
  only LJ potential with epsilon,sigma = 1.0 is currently supported
  units = LJ sigma
  default = 2.5
rates 0.1
  set deposition rate (1/sec)
  default = 1.0

run 100
  run for this many events
temperature 1.5
  set temperature for Boltzmann factor (reduced LJ temperature units)
  default = 0.0
stats 5
  print stats every this many events
dump 10
  dump snapshot every this many events in LAMMPS atom format

-----------------------------------------------------------------------
* app_style test/group and test/group2

app_style test/group
app_style test/group2

run an app to test group solver performance
two versions of this app
  group = Alex's original version
  group2 = Steve's trimmed down version (used for JCP paper)

also need to define a "solve" style:
  see "* solve_style" below

Extra commands supported by this app:

event           200  30 1
  Defines properties of the event table:
  1. Size of event table
  2. Max number of dependencies
  3. Size of propensity adjustment (%)
  4. [optional] Low memory switch to generate
  dependencies randomly on the fly instead
  of storing the event table.
  5. Random seed for the low_mem option.
  
  Examples:
  event           200  30 1
  event           200  30 1 lo_mem 384745

run 0.5
  run for time (seconds)

-----------------------------------------------------------------------
* clear

clear (no args)

wipe out simulation, start over
see HTML doc page

-----------------------------------------------------------------------
* echo

echo none/screen/log/both

echo each command to screen and/or log file
useful for debugging
see HTML doc page

-----------------------------------------------------------------------
* include

include filename

branch to another input script file and then return to this one
useful for including a set of commands, e.g. list of reactions
see HTML doc page

-----------------------------------------------------------------------
* jump

jump filename
jump filename label

jump to beginning of another file or to a label in the file
file can be self, in which case used for looping
see HTML doc page

-----------------------------------------------------------------------
* label

label ID

mark a position in file that a "jump" will return to, e.g. start of a loop
see HTML doc page

-----------------------------------------------------------------------
* log

log filename

name of log file to start printint output to
see HTML doc page

-----------------------------------------------------------------------
* next

next v1 v2 ...

list of one or more variables to increment, e.g. at end of loop
see "variable" command
see HTML doc page

-----------------------------------------------------------------------
* print

print string of words and $v to print out

see HTML doc page

-----------------------------------------------------------------------
* shell

shell cd sub1
shell cd ..
shell mkdir tmp1 tmp2 tmp3
shell rmdir tmp1
shell mv log.kmc hold/log.1
shell rm TMP/file1 TMP/file2 :pre

various shell commands that can be executed from input script
cd changes dirs permanently for opening/closing files
see HTML doc page

-----------------------------------------------------------------------
* solve_style

solve_style linear seed
solve_style tree seed
solve_style alias seed
solve_style group lo hi seed
solve_style group lo hi ngroups seed
solve_style gppt seed

seed = RN seed
lo,hi = range of propensities
ngroups = 0 (or not listed), use logarithmic scaling
ngroups > 1, use this number of groups

update of sites owned by a processor via a KMC algorithm
  which chooses events and associated timesteps randomly
used when running a non lattice app (chemistry, surf, test)
  can only run on 1 processor
if used with a lattice app (ising, potts, membrane, migration)
  and no sweep style is set
    can only run on 1 processor
    entire domain is treated via KMC
if used with a lattice app and a sweep style is set
  if running on 1 processor, domain is partitioned into sectors
    KMC is run on each and periodic boundaries are updated after each event
  if running in parallel, each proc's sub-domain is partitioned into sectors
    KMC is run on each and boundaries are updated between sectors
    this is an approximate parallel KMC algorithm

style linear chooses the next event in linear, cost = O(N)
  update of propensities is O(1)
style tree chooses the next event from a binary tree, cost = O(NlogN)
  update of propensities is also O(NlogN)
style alias does what?
style group does what?
style gppt does what?

-----------------------------------------------------------------------
* stats 0.1
  print stats every this often (seconds)

  there is now an option called logfreq:

  This gives t = 0,0.01,0.02,...,0.07,1.0,2.0,....,7.0,10.0,20.0,....
  stats       0.01 logfreq 7 10.0

  This gives t = 0,0.01,0.02,0.04,0.08,...
  stats           0.01 logfreq 1 2.0

-----------------------------------------------------------------------
* sweep_style

sweep_style lattice2d seed option arg option arg ...
sweep_style lattice3d seed option arg option arg ...

options and args:
  strict yes/no = enforce ??
  mask yes/no = use a mask on each site to skip if possible
  picklocal yes/no = pick new spin from neighbors or all possible
  kmc yes/no = run KMC on sub-domain or sweep in ordered fashion
  delt 1.0 = time associated with one sweep (seconds)

defaults:
  strict no, mask no, picklocal no, kmc no, delt = 1.0

perform a Metroplis or KMC update of sites owned by a processor
  by sweeping over lattice sites in a regular fashion
must use lattice2d or lattice3d that correspods to the app_style (2d or 3d)
  do we check for this ??
used when running a lattice-based app (ising, potts, membrane, migration)

if define just a sweep style:
  domain will be broken into 4 or 8 sectors for 2d or 3d
  each will be iterated on in turn
  communication of boundary info will be done between sectors
if define just a solve style:
  no sweeping is done
  entire domain is treated as one set of KMC propensities
if define both a sweep and solve style:
  same partitioning into 4 or 8 sectors is done
  each sector is treated as one set of KMC propensities
  KMC updates are done until delt is reached
  then boundary is updated via communication
  this is an approximate parallel KMC algorithm
if use sweep style when running on 1 proc, entire domain is partitioned
  into 4 or 8 sectors

what does each option mean ??
which options can be used in combination and what do they mean ??
if KMC option is used, options strict, picklocal, mask are ignored
for KMC option, it's important to choose delt correctly
  how to choose correctly ??
  what happens if too small
  what happens if too large

-----------------------------------------------------------------------
* variable

variable name style args ...

define and set value(s) for a variable that can be accessed elsewhere in script
style = index, loop, equal, world, universe, uloop
access is via $x or ${myvar}
see HTML doc page

-----------------------------------------------------------------------
* diag_style

diag_style style delta arg option arg option ...

Run a diagnostic function called style after every delta time units.

There diagnostic functions available are: 

cluster
cluster3d
cluster2d
eprof3d
energy
energy2d
energy3d

The energy profile is only available for the 3D 
lattice apps. It prints the average energy per site for each slab of sites
in the x, y or z directions.

diag_style	eprof3d 0.1 x eprof3d.dat

Cluster analysis is available for 3D, 2D, general lattice apps, if the 
push_connected_neighbors() and connected_ghosts() functions have been
defined. If not, SPPARKS will exit with a helpful error message. Clustering uses
a application-definition of site-site connectivity (e.g. sites are adjacent and have same
spin value) to identify the set of connected clusters. It prints the
number of sites in each cluster to a file. If a dump_style option is
given, then the cluster id for each site is printed out. The cluster ids
are arbitrary integers such that two sites have the same id if and only
if they belong to the same cluster. The standard dump_style generates 
LAMMPS-like output with two columns: site index and cluster id. The 
opendx dump_style generates a file that can be read by the OpenDX script
called aniso0.net to visualize the clusters in 3D. OpenDX can also be used to
visualize 2D lattices.

diag_style      cluster3d 1.0 filename cluster3d.a.0.1.dat dump_style opendx cluster3d.a.0.1.dump
